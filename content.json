{"meta":{"title":"Layne","subtitle":"I am a slow walker, but I never walk backwards.","description":"java,jvm,算法,并发","author":"layne Li","url":"http://layne.ink"},"pages":[{"title":"全部分类","date":"2018-07-10T10:13:59.000Z","updated":"2018-07-11T02:54:22.444Z","comments":false,"path":"categories/index.html","permalink":"http://layne.ink/categories/index.html","excerpt":"","text":""},{"title":"全部标签","date":"2018-07-10T10:13:41.000Z","updated":"2018-07-11T02:54:08.244Z","comments":false,"path":"tags/index.html","permalink":"http://layne.ink/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-07-10T09:48:31.582Z","updated":"2018-07-10T09:48:31.582Z","comments":true,"path":"2018/07/10/hello-world/","link":"","permalink":"http://layne.ink/2018/07/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"init与clinit解析","slug":"init与clinit解析","date":"2016-07-11T02:57:43.000Z","updated":"2018-07-11T05:23:53.457Z","comments":true,"path":"2016/07/11/init与clinit解析/","link":"","permalink":"http://layne.ink/2016/07/11/init与clinit解析/","excerpt":"clinit：在jvm第一次加载class文件时调用，包括静态变量初始化和静态语句块的执行。 init:在实例创建出来的时候调用，包括调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。","text":"clinit：在jvm第一次加载class文件时调用，包括静态变量初始化和静态语句块的执行。 init:在实例创建出来的时候调用，包括调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。（1）clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在他之后的变量，在前面的静态语句块中可以赋值但不能访问。 1234567public class Test&#123; static&#123; i = 0; //给变量赋值可以正常通过 System.out.println(i); //这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; （2）clinit()方法与类的构造函数（或者说实例构造器中的init()方法）不同， 它不需要显示的调用父类构造器，虚拟机会保证在子类的init()方法执行之前，父类的clinit()方法已经执行完毕。因为在虚拟机中第一个被执行的clinit()方法的类肯定是java.lang.Object。 （3）由于父类的clinit()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。 （4）clinit()方法对于类或者接口来说并不是必须的，如果一个类没有静态语句块，也就没有变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。 （5）接口中不能使用静态语句块，但仍然可以有变量初始化的赋值操作，因此接口与类一样都会生成clinit()方法。但接口与类不同，执行接口的clinit()方法不需要先执行父接口的clinit()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的clinit()方法。 （6）虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的clinit()方法中有耗时很长的操作，就可能造成多个线程阻塞。","categories":[{"name":"jvm","slug":"jvm","permalink":"http://layne.ink/categories/jvm/"}],"tags":[{"name":"java","slug":"java","permalink":"http://layne.ink/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://layne.ink/tags/jvm/"}]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2016-05-11T08:25:56.000Z","updated":"2018-07-11T12:31:56.819Z","comments":true,"path":"2016/05/11/序列化与反序列化/","link":"","permalink":"http://layne.ink/2016/05/11/序列化与反序列化/","excerpt":"","text":"引言将 Java 对象序列化为二进制文件的 Java 序列化技术是 Java 系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用ObjectInputStream和ObjectOutputStream进行对象的读写。然而在有些情况下，光知道这些还远远不够，文章列举了笔者遇到的一些真实情境，它们与 Java 序列化相关，通过分析情境出现的原因，使读者轻松牢记 Java 序列化中的一些高级认识。 关于序列化 ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。即使两个类的功能代码完全一致，但是序列化 ID 不同，他们也无法相互序列化和反序列化。 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。 序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。 静态变量序列化清单 1. 静态变量序列化问题代码 12345678910111213141516171819202122232425262728293031323334 public class Test implements Serializable &#123; private static final long serialVersionUID = 1L; public static int staticVar = 5; public static void main(String[] args) &#123; try &#123; //初始时staticVar为5 ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\"result.obj\")); out.writeObject(new Test()); out.close(); //序列化后修改为10 Test.staticVar = 10; ObjectInputStream oin = new ObjectInputStream(new FileInputStream( \"result.obj\")); Test t = (Test) oin.readObject(); oin.close(); //再读取，通过t.staticVar打印新的值 System.out.println(t.staticVar); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 清单 1 中的 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单 1，这个 System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？ 最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。 父类的序列化与 Transient 关键字情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。 解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 特性使用案例 我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，不用重复书写 transient，代码更简洁。 对敏感字段加密情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 2 展示了这个过程。清单 2. 静态变量序列化问题代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static final long serialVersionUID = 1L;private String password = \"pass\";public String getPassword() &#123; return password;&#125;public void setPassword(String password) &#123; this.password = password;&#125;private void writeObject(ObjectOutputStream out) &#123; try &#123; PutField putFields = out.putFields(); System.out.println(\"原密码:\" + password); password = \"encryption\";//模拟加密 putFields.put(\"password\", password); System.out.println(\"加密后的密码\" + password); out.writeFields(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;private void readObject(ObjectInputStream in) &#123; try &#123; GetField readFields = in.readFields(); Object object = readFields.get(\"password\", \"\"); System.out.println(\"要解密的字符串:\" + object.toString()); password = \"pass\";//模拟解密,需要获得本地的密钥 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;public static void main(String[] args) &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\"result.obj\")); out.writeObject(new Test()); out.close(); ObjectInputStream oin = new ObjectInputStream(new FileInputStream( \"result.obj\")); Test t = (Test) oin.readObject(); System.out.println(\"解密后的字符串:\" + t.getPassword()); oin.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 在清单 2 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对 password 进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。 特性使用案例 RMI 技术是完全基于 Java 序列化技术的，服务器端接口调用所需要的参数对象来自于客户端，它们通过网络相互传输。这就涉及 RMI 的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。 序列化存储规则清单 3. 存储规则问题代码 1234567891011121314151617181920ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\"result.obj\"));Test test = new Test();//试图将对象两次写入文件out.writeObject(test);out.flush();System.out.println(new File(\"result.obj\").length());out.writeObject(test);out.close();System.out.println(new File(\"result.obj\").length());ObjectInputStream oin = new ObjectInputStream(new FileInputStream( \"result.obj\"));//从文件依次读出两个文件Test t1 = (Test) oin.readObject();Test t2 = (Test) oin.readObject();oin.close();//判断两个引用是否指向同一个对象System.out.println(t1 == t2); 清单 3 中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输出 false 才对，但是第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？ 解答：Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3 中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。 特性案例分析 清单 4. 案例代码 1234567891011121314ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"result.obj\"));Test test = new Test();test.i = 1;out.writeObject(test);out.flush();test.i = 2;out.writeObject(test);out.close();ObjectInputStream oin = new ObjectInputStream(new FileInputStream( \"result.obj\"));Test t1 = (Test) oin.readObject();Test t2 = (Test) oin.readObject();System.out.println(t1.i);System.out.println(t2.i); 清单 4 的目的是希望将 test 对象两次保存到 result.obj 文件中，写入一次以后修改对象属性值再次保存第二次，然后从 result.obj 中再依次读出两个对象，输出这两个对象的 i 属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。 结果两个输出的都是 1， 原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 时需要特别注意这个问题。","categories":[{"name":"io","slug":"io","permalink":"http://layne.ink/categories/io/"}],"tags":[{"name":"io","slug":"io","permalink":"http://layne.ink/tags/io/"}]}]}