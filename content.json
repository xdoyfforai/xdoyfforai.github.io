{"meta":{"title":"Layne","subtitle":"I am a slow walker, but I never walk backwards.","description":"java,jvm,算法,并发","author":"layne Li","url":"http://layne.ink"},"pages":[{"title":"全部分类","date":"2018-07-10T10:13:59.000Z","updated":"2018-07-11T02:54:22.444Z","comments":false,"path":"categories/index.html","permalink":"http://layne.ink/categories/index.html","excerpt":"","text":""},{"title":"全部标签","date":"2018-07-10T10:13:41.000Z","updated":"2018-07-11T02:54:08.244Z","comments":false,"path":"tags/index.html","permalink":"http://layne.ink/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"init与clinit解析","slug":"init与clinit解析","date":"2016-07-11T02:57:43.000Z","updated":"2018-07-11T05:01:46.540Z","comments":true,"path":"2016/07/11/init与clinit解析/","link":"","permalink":"http://layne.ink/2016/07/11/init与clinit解析/","excerpt":"","text":"clinit：在jvm第一次加载class文件时调用，包括静态变量初始化和静态语句块的执行。 init:在实例创建出来的时候调用，包括调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。 （1）clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在他之后的变量，在前面的静态语句块中可以赋值但不能访问。 1234567public class Test&#123; static&#123; i = 0; //给变量赋值可以正常通过 System.out.println(i); //这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; （2）clinit()方法与类的构造函数（或者说实例构造器中的init()方法）不同， 它不需要显示的调用父类构造器，虚拟机会保证在子类的init()方法执行之前，父类的clinit()方法已经执行完毕。因为在虚拟机中第一个被执行的clinit()方法的类肯定是java.lang.Object。 （3）由于父类的clinit()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。 （4）clinit()方法对于类或者接口来说并不是必须的，如果一个类没有静态语句块，也就没有变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。 （5）接口中不能使用静态语句块，但仍然可以有变量初始化的赋值操作，因此接口与类一样都会生成clinit()方法。但接口与类不同，执行接口的clinit()方法不需要先执行父接口的clinit()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的clinit()方法。 （6）虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的clinit()方法中有耗时很长的操作，就可能造成多个线程阻塞。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://layne.ink/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://layne.ink/tags/jvm/"}]}]}